@Tutorial(time: 5, projectFiles: "Streamy.zip") {
    @Intro(title: "Logging Sensor Data") {
        Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder.
        @Image(source: streamyIcon.png, alt: "Streamy app icon")
    }
    
    @Section(title: "To Log or Download?") {
        @ContentAndMedia {
            Create a UseCase detecting if the MetaWear flash storage contains any logged data, suggesting the relevant call to action.
            @Image(source: bird-rainbow.png, alt: "Bird art")
        }
        
        @Steps {
            @Step {
                Issuing the `logLength` command returns the used flash storage in bytes, as counted by pages occupied. 
                
                If no bytes are used, it's time to start a new logging session. Otherwise, _Streamy_ should offer to download the data.
                @Code(name: "NextSteps.swift", file: 03-recording-00-00.swift, previousFile: 03-recording-00-00_mask.swift) 
            }  
        }
    }
    
    @Section(title: "Configure logging commands") {
        @ContentAndMedia {
            Create a UseCase that composes a logging session with a valid group of sensors and commands the MetaWear to start logging.
            @Image(source: bird-rainbow.png, alt: "Bird art")
        }
        
        @Steps {
            @Step {
                We'll start with a MetaWear reference and metadata.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-00.swift, previousFile: 03-recording-01-00_mask.swift) 
            }  
            @Step {
                When a MetaWear logs its sensors, the activity is given an identifier String. The SDK catalogs these as ``MetaWear/MWNamedSignal``. We'll use that enum as a rough-and-ready way to present options for logging.
                
                _Streamy_ will offer the accelerometer and gyroscope, plus two modes that fuse the accelerometer and gyroscope together.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-01.swift, previousFile: 03-recording-01-01_mask.swift) 
            }  
            @Step {
                When fusing the accelerometer and gyroscope together, it's not possible to log those sensors individually. We'll ask the SDK for some logic to ensure our updates to the Set keeps the two fused modes exclusive to logging individual sensors (and another fused mode).
                
                If any sensors are selected, we'll enable the call to action.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-02.swift) 
            } 
            
            @Step {
                Programming a logging session is fast, but the MetaWear might not yet be connected. We'll set a flag saying something's happening.
                
                @Code(name: "SensorLogging.swift", file: 03-recording-01-03.swift) 
            }
            
            @Step {
                The `.log` and `.optionallyLog` Combine operators in the SDK ask for an object conforming to ``MetaWear/MWLoggable``. Exact details are not important. It tells the SDK how to configure and obtain a sensor's loggable signal, which varies by sensor model. What you do need to know is that code completion will find any options for you.
                
                For streaming, one-time reads, and one-time commands, there are also ``MetaWear/MWStreamable``, ``MetaWear/MWReadable``, and ``MetaWear/MWCommand``. Some sensors can only be streamed or logged by polling, hence ``MetaWear/MWPollable``. These are sorta-don't-cares. Overloads on `log` and `stream` handle the details for you.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-04.swift) 
            }  
            
            @Step {
                To organize calling a series of `.optionallyLog` commands, _Streamy_ uses a configuration container based on the selected sensors.
                
                You can instantiate `MWLoggable` conforming types yourself, similar to SwiftUI styles. Our open source _MetaBase 5_ uses this strategy to merge an array of optional streaming publishers.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-05.swift) 
            }  
            
            @Step {
                Once the commands issue, _Streamy_ enables the download action.
                @Code(name: "SensorLogging.swift", file: 03-recording-01-06.swift) 
            }
        }
    }
    
    @Section(title: "Download data") {
        @ContentAndMedia {
            Collect logged data into exportable CSV files.
            @Image(source: bird-gray-yellow.png, alt: "Bird art")
        }
        
        @Steps {
            @Step {
                The SDK's `.downloadLogs` command asks for a `Date` when logging started. This aligns the timestamps of datapoints across groups of MetaWears, as each will start logging at different times due to Bluetooth delays.
                
                For demo purposes _Streamy_ just injects the current time. A real app should have cached a timestamp back when the log command succeeded.
                @Code(name: "Download.swift", file: 03-recording-02-01.swift, previousFile: 03-recording-02-01_mask.swift) 
            }    
            
            @Step {
                The `download` operators will emit progress updates approximately every 4%. At 100%, the collected data arrives.
                
                This percentage is a rough estimate from counting flash storage pages. If the last page was only minimally filled with data, you'll see progress leap to 100%.
                @Code(name: "Download.swift", file: 03-recording-02-02.swift) 
            }  
            
            @Step {
                _Streamy_ passes the data component of the download tuple for CSV formatting.
                @Code(name: "Download.swift", file: 03-recording-02-03.swift) 
            }  
            
            @Step {
                Translate the array of ``MetaWear/MWDataTable`` into CSV-formatted Data by calling ``MetaWear/MWDataTable/makeCSV(delimiter:)``.
                
                Each table represents one sensor. Use ``MetaWear/MWDataTable/source`` for its name. The time-related columns and decimal digits of the output are customizable. (When streaming data, the SDK returns timestamped `SIMD<Float>` and other native types.)
                @Code(name: "Download.swift", file: 03-recording-02-04.swift, previousFile: 03-recording-02-04_mask.swift) 
            }  
            
            @Step {
                Export and archive these CSVs as needed.
                
                _Streamy_ writes these files to a temp folder. A `FileWrapper` for that folder is embedded in a `FileDocument` to align with a SwiftUI API. _MetaBase_ archives the files to CoreData and iCloud and exports them using AppKit and UIKit APIs.
                @Code(name: "Download.swift", file: 03-recording-02-05.swift) 
            } 
        }
    }
}
