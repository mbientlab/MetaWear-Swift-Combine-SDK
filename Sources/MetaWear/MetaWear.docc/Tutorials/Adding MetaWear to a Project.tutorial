@Tutorial(time: 5, projectFiles: "Streamy.zip") {
    @Intro(title: "Adding MetaWear to a Project") {
        This tutorial examines the dependencies and permissions needed for the SDK. We'll also look at Streamy, a demo app that implements the code seen here.
        @Image(source: streamyIcon.png, alt: "Streamy app icon")
    }
    
    @Section(title: "What We'll Cover (and What We Won't)") {
        @ContentAndMedia {
            Our Combine SDK is available using Xcode's native package dependency manager.
            @Image(source: bird-red.png, alt: "Bird art")
        }
        @Steps {
            @Step { 
                For brevity, this tutorial will skip UI-related code. We'll only examine UseCase objects and Combine pipelines related to the SDK.
                
                _Streamy_ is built to be modular. All views depend on generic ObservableObjects (i.e., use cases) and call on other generic views, so you can tinker with Streamy easily bit by bit to build a mockup app.
                @Code(name: "App.swift", file: 01-root-02-07.swift, reset: true) {}
            }
        }
    }
    
    @Section(title: "Swift Package Manager & Permissions") {
        @ContentAndMedia {
            Our Combine SDK is available using Xcode's native package dependency manager.
            @Image(source: bird-red.png, alt: "Bird art")
        }
        @Steps {
            @Step { 
                In the File menu, choose Add Package...
                https://github.com/mbientlab/MetaWear-Swift-Combine-SDK
                
                By default, Xcode will update the MetaWear package when minor versions are released, but not for a major release. You can also depend on a branch head or a commit. 
                @Image(source: tut-AddPackage.png, alt: ".")
            }
            @Step { 
                Add all frameworks but Firmware to your Streamy target. (We won't be updating device firmware.) 
                @Image(source: tut-AddPackageProducts.png, alt: ".")
            }
            @Step { 
                Xcode will likely only add these frameworks to one of your tragets. Remedy this by tapping the + icon inside the `Frameworks, Libraries and Embedded Content` section to add the same frameworks as above. 
                @Image(source: tut-ManuallyAddProducts.png, alt: ".")
            }
            @Step { 
                Don't forget to set the two Info.plist Bluetooth privacy usage descriptions. Your app will not function otherwise.
                @Image(source: tut-Plist.png, alt: ".")
            }
            @Step { 
                For macOS, match permissions to this screenshot. Ensure App Sandbox -> Bluetooth and iCloud -> CloudKit permissions are enabled.
                @Image(source: tut-MacPermissions.png, alt: ".")
            }
            @Step { 
                For iOS, we need to check different boxes. Add Background Modes and check Uses Bluetooth LE accessories. Add iCloud, checking Key value storage.
                @Image(source: tut-iOSPermissions.png, alt: ".")
            }
        }
    }
    
    @Section(title: "The Core SDK Classes") {
        @ContentAndMedia {
            We'll use three core classes: ``MetaWear/MetaWear``, ``MetaWear/MetaWearScanner``, and `MetaWearSyncStore`. 
            
            When debugging, the ``MetaWear/MWConsoleLogger`` can visualize Bluetooth communications.
            @Image(source: bird-red-yellow.png, alt: "Bird art")
        }
        @Steps {
            @Step { 
                Let's look at how we could wire up the SDK inside an app's root object.
                @Code(name: "Root.swift", file: 01-root-01-01.swift) {}
            }    
            @Step { 
                The ``MetaWear/MetaWearScanner`` abstracts the CoreBluetooth framework for you, finding nearby ``MetaWear`` devices. The ``MetaWear/MetaWearScanner/sharedRestore`` singleton enables CoreBluetooth to recognize this app and vend it previously used peripherals.
                @Code(name: "Root.swift", file: 01-root-01-02.swift, previousFile: 01-root-01-02_mask.swift) {}
            } 
            @Step { 
                To persist names, capabilities, and other data about previously connected MetaWears, the scanner and other SDK components use UserDefaults storage. 
                
                **FYI** - You can inspect the keys used and specify the container at `UserDefaults.MetaWear.suite`. By default, the SDK uses `.standard`. 
                @Code(name: "Root.swift", file: 01-root-01-03.swift) {}
            }
            @Step { 
                Apple randomizes Bluetooth device identifiers between devices. It also blocks inspecting advertised MAC addresses. 
    
                The `MetaWearSyncStore` allows you to stably identify MetaWears across devices by saving de-identifying metadata to iCloud key value storage, including a device's name, serial number, and sensor capabilities. If you choose to use this feature, obtain and manage MetaWears exclusively through the sync store, rather than the Scanner.
                @Code(name: "Root.swift", file: 01-root-01-04.swift) {}
            }
            @Step { 
                An iCloud key value store must be synchronized at launch to obtain the latest values.
                @Code(name: "Root.swift", file: 01-root-01-05.swift) {}
            }
            @Step { 
                When debugging, you might find the ``MetaWear/MWConsoleLogger`` helpful. If you set ``MetaWear/MWConsoleLogger/activateConsoleLoggingOnAllMetaWears`` to true, all MetaWears will report activities (e.g., Bluetooth packets) to the console in Debug mode.
                
                **Tip** _You can also setup logging for individual MetaWears by assigning a delegate conforming to ``MetaWear/MWConsoleLoggerDelegate``._
                @Code(name: "Root.swift", file: 01-root-01-06.swift) {}
            }
        }
    }
}
