{"metadata":{"title":"Connecting to MetaWears","categoryPathComponent":"MetaWear","role":"project","category":"MetaWear"},"hierarchy":{"modules":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Swift-Package-Manager"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Add-MetaWear-and-MetaWearSync"}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#List-nearby-devices"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#First-connection"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#Managing-known-devices"}]}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Log-Sensor-Data","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Configure-logging-commands"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Download-data"}]}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Train-a-CoreML-Model","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification#Forthcoming"}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model#Forthcoming"}]}]}],"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear","paths":[["doc:\/\/MetaWear\/tutorials\/MetaWear","doc:\/\/MetaWear\/tutorials\/MetaWear\/$volume","doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect"]]},"schemaVersion":{"major":0,"minor":2,"patch":0},"kind":"project","identifier":{"url":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","interfaceLanguage":"swift"},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}]}],"estimatedTimeInMinutes":10,"title":"Connecting to MetaWears","image":"streamyIcon.png","chapter":"Discover & Connect","kind":"hero","backgroundImage":"streamyIcon.png","projectFiles":"Streamy.zip"},{"kind":"tasks","tasks":[{"anchor":"List-nearby-devices","title":"List nearby devices","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"List MetaWears by the best available identifier: either a stable "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress"},{"type":"text","text":" or a locally-unique CoreBluetooth "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/CBPeripheralIdentifier"},{"type":"text","text":" UUID."}]}],"mediaPosition":"trailing","media":"bird-green-yellow.png"}],"stepsSection":[{"code":"02-connecting-01-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MetaWears not previously connected can be identified by the "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" CoreBluetooth provides. For privacy reasons, Apple randomizes these ids between host machines. Once connected, the MetaWear SDK reads and stores the device’s stable MAC address."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"By syncing MAC addresses and local UUIDs across iOS and macOS devices, the SDK allows you to stably identify a MetaWear or groupings of MetaWears."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Instruct CoreBluetooth to start scanning for new nearby devices and send references to any previously used devices."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Scanning consumes energy. Stop scanning when there isn’t UI to handle new discoveries."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"higherPerformanceMode"},{"type":"text","text":" flag increases the frequency of new discoveries — and energy use. CoreBluetooth calls this flag the "},{"type":"codeVoice","code":"CBCentralManagerScanOptionAllowDuplicatesKey"},{"type":"text","text":"."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Subscribe to a Publisher that streams UUIDs of nearby MetaWears that haven’t been used before."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This SDK uses the "},{"type":"codeVoice","code":"Combine"},{"type":"text","text":" framework to reason about asynchronous events and value streams. In Combine, a Publisher emits values over time, either forever or terminating with a success or failure. To subscribe to this stream and hold it memory, Combine publishing pipelines return a token, called an "},{"type":"codeVoice","code":"AnyCancellable"},{"type":"text","text":". This is a class you can store individually or in a Set. These tokens terminate and deallocate when the parent object deallocates, when you replace the token, or call "},{"type":"codeVoice","code":".cancel()"},{"type":"text","text":". To learn more, we suggest "},{"type":"reference","isActive":true,"identifier":"https:\/\/heckj.github.io\/swiftui-notes\/"},{"type":"text","text":"."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This SDK’s publishers and objects all start and return work on a serial DispatchQueue to ensure the underlying C\/C++ library’s proper operation. All SDK objects expose this queue, for example the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/bleQueue"},{"type":"text","text":" on a MetaWear."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To update UI, use "},{"type":"codeVoice","code":".receive(on:)"},{"type":"text","text":" to dispatch the remainder of the pipeline asynchronously to the main queue."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Terminate the pipeline with "},{"type":"codeVoice","code":"sink"},{"type":"text","text":". Any received updates will be sorted for stability before replacing the local published array."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To prevent retain cycles, weakify self and other captured objects in Combine closures."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Subscribe to updates of previously used MetaWears’ metadata, including those only used on other host machines."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-08.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"After sorting each update by the device’s name for stability, assign the MAC addresses to the locally published array."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"First-connection","title":"First connection","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Provide a name, signal strength, and a connection intent for newly discovered MetaWears."}]}],"mediaPosition":"trailing","media":"bird-teal.png"}],"stepsSection":[{"code":"02-connecting-02-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ask the sync store to vend a reference to a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear"},{"type":"text","text":" held by "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":"."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve a name from metadata, if available, or the MetaWear’s Bluetooth advertised name."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If using a valid UUID from the current app session, the MetaWear reference will never be nil."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To smooth out UI after a user asks to “forget” a MetaWear, some metadata will still exist in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear"},{"type":"text","text":" instance. You can reflect such state by testing if the sync store provided a metadata object."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Depict signal strength by subscribing to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Signal strength updates occur in three scenarios. (1) When "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":" is actively scanning. (2) Explicitly by calling "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/updateRSSI()"},{"type":"text","text":". (3) Implicitly by subscribing to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher"},{"type":"text","text":", which ensures at least one update occurs every 5 seconds until unsubscribed."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Expose a “remember device” action, asking the sync store to connect and record the device’s identity."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Once successful, the callback provides the connected MetaWear and its metadata for temporary use."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s use that callback to flash the LEDs on the MetaWear. Ask the MetaWear to kickoff a Combine pipeline. Issue a command, using autocomplete to choose a preset flash pattern."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWLED\/Flash\/Pattern\/Emulator"},{"type":"text","text":" can drive UI that mimics the flash command. For an example SwiftUI view using the emulator, see the "},{"type":"codeVoice","code":"mbientSwiftUI"},{"type":"text","text":" repository on GitHub."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"One hitch. The sync store will diff its list of devices, likely deallocating this controller before the flash command issues or completes."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this barebones app, our fix is to get a reference to the parent list controller and store this pipeline there."}]}],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"Managing-known-devices","title":"Managing known devices","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Issue commands, like rename, reset, or forget, and keep the displayed name up-to-date."}]}],"mediaPosition":"trailing","media":"bird-blue.png"}],"stepsSection":[{"code":"02-connecting-03-00.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ask the sync store to vend an optional MetaWear and metadata object, delivered as an optional tuple."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", this controller instantiates only for known devices. Force unwrapping the tuple will never fail. Metadata will always be present, but a MetaWear reference could be nil, as this might be a cloud-synced MetaWear never used locally before."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Track connection progress with publisher."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tip: To make depicting UI state a little, MetaWear conforms "},{"type":"codeVoice","code":"CBPeripheralState"},{"type":"text","text":" to Comparable so you can use logic like "},{"type":"codeVoice","code":"<"},{"type":"text","text":" or "},{"type":"codeVoice","code":"..<"},{"type":"text","text":"."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" will show an iCloud glyph and disables any buttons that issue connection-dependent commands if a MetaWear isn’t locally available from CoreBluetooth."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When this MetaWear is brought nearby and connected, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" needs to recover from this locked state."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ask the sync store for a publisher that fires when this MAC address’s metadata or MetaWear reference changes."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, let’s also kick off the RSSI and connection state publishers that would have failed to start in "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" when the MetaWear reference was nil."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add connect and disconnect actions."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To forget devices, use the sync store."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The scanner also has this command, but calling it will leave the sync store unawares, rendering it unstable."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To reset a MetaWear, let’s issue a one-time command. The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenConnected()"},{"type":"text","text":" publisher fires every time a MetaWear connects. Use "},{"type":"codeVoice","code":".first()"},{"type":"text","text":" to terminate the pipeline after one event. Calling "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connect()"},{"type":"text","text":" will start connecting to the MetaWear (if not already connected)."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This await-kickoff pattern is common for this SDK. Other kick offs include "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenDisconnected()"},{"type":"text","text":" or "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishIfConnected()"},{"type":"text","text":", which errors out if not presently connected."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-08.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reset commands come in gradations of severity: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetFactoryDefaults"},{"type":"text","text":" nukes everything, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetActivities"},{"type":"text","text":" strips macros or loggers but not settings, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/macroEraseAll"},{"type":"text","text":" strips just macros, and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/restart"},{"type":"text","text":" preserves macros, loggers and settings, but purges in-memory activities."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If your MetaWear crashes on connect, use the factory reset to break the bad state caused by a faulty command or Bluetooth hiccup."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-09.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To find one MetaWear in a stack of lookalikes, offer to flash its LED."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The Presets enum conforms to CaseIterable, so you could configure a list of MetaWears with up to 10 distinct patterns… or compose your own."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-10.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, let’s ask the sync store to rename a MetaWear. Providing a name that’s too long or contains invalid characters will throw an error."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" will use a quick-and-dirty published Bool to coordinate recovery from an invalid rename using the SwiftUI alert API."}]}],"type":"step","runtimePreview":null,"media":null}]}]},{"action":{"overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"isActive":true,"type":"reference","identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","kind":"callToAction","title":"Logging Sensor Data","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}]}],"references":{"bird-teal.png":{"alt":"Bird art","type":"image","identifier":"bird-teal.png","variants":[{"url":"\/images\/bird-teal@1x.png","traits":["1x","light"]}]},"02-connecting-03-00.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    @Published private(set) var rssi: Int","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var rssiSub:       AnyCancellable? = nil","","    init(knownDevice: MACAddress, sync: MetaWearSyncStore) {","        self.sync = sync","        (self.metawear, self.metadata) = sync.getDeviceAndMetadata(knownDevice)!","        self.rssi = self.metawear?.rssi ?? -100","    }","","    func onAppear() {","        trackRSSI()","    }","}","","private extension KnownDeviceController {","","    func trackRSSI() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-00.swift","type":"file","fileType":"swift","highlights":[{"line":11}]},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data#Configure-logging-commands":{"role":"pseudoSymbol","title":"Configure logging commands","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Configure-logging-commands","kind":"section","type":"section","url":"\/tutorials\/metawear\/logging-sensor-data#Configure-logging-commands"},"02-connecting-01-01.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    init() {","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-01.swift","type":"file","fileType":"swift","highlights":[]},"02-connecting-03-03.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var identitySub:   AnyCancellable? = nil","","    ...","","    func onAppear() {","        trackIdentity()","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceController {","","    func trackIdentity() {","        identitySub = sync?.publisher(for: metadata.mac)","            .receive(on: DispatchQueue.main)","            .sink { [weak self] metawear, metadata in","                self?.metawear = metawear","                self?.metadata = metadata","            }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-03.swift","type":"file","fileType":"swift","highlights":[{"line":12},{"line":17},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32}]},"02-connecting-01-05.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-05.swift","type":"file","fileType":"swift","highlights":[{"line":2},{"line":26},{"line":27}]},"02-connecting-01-03.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","","    init(_ scanner: MetaWearScanner) {","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-03.swift","type":"file","fileType":"swift","highlights":[{"line":20},{"line":21},{"line":22},{"line":23}]},"doc://MetaWear/tutorials/MetaWear/Train-a-CoreML-Model":{"role":"article","title":"Train a CoreML Model","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Train-a-CoreML-Model","kind":"article","type":"topic","url":"\/tutorials\/metawear\/train-a-coreml-model"},"bird-blue.png":{"alt":"Bird art","type":"image","identifier":"bird-blue.png","variants":[{"url":"\/images\/bird-blue@1x.png","traits":["1x","light"]}]},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project":{"role":"project","title":"Adding MetaWear to a Project","estimatedTime":"5min","abstract":[{"type":"text","text":"This tutorial guides you through building "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", an app to capture and analyze motion sensor data."},{"type":"text","text":" "},{"type":"text","text":"You’ll start by adding the MetaWear SDK using Swift Package Manager and then link up dependencies."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project","kind":"project","type":"topic","url":"\/tutorials\/metawear\/adding-metawear-to-a-project"},"doc://MetaWear/tutorials/MetaWear/Training-Activity-Classification":{"role":"project","title":"Training Activity Classification","estimatedTime":"20min","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification","kind":"project","type":"topic","url":"\/tutorials\/metawear\/training-activity-classification"},"bird-green-yellow.png":{"alt":"Bird art","type":"image","identifier":"bird-green-yellow.png","variants":[{"url":"\/images\/bird-green-yellow@1x.png","traits":["1x","light"]}]},"02-connecting-03-05.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","","    ...","","    func connect() {","        metawear?.connect()","    }","","    func disconnect() {","        metawear?.disconnect()","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-05.swift","type":"file","fileType":"swift","highlights":[{"line":11},{"line":12},{"line":13},{"line":15},{"line":16},{"line":17}]},"02-connecting-02-05.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var isConnecting = false","","    private weak var metawear: MetaWear?","    private weak var sync:     MetaWearSyncStore?","    private      var rssiSub:  AnyCancellable? = nil","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","        self.isCloudSynced = metadata != nil","        self.rssi = metawear.rssi","        self.sync = sync","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID else { return }","        isConnecting = true","","        sync?.connectAndRemember(unknown: id, didAdd: { (device, metadata) in","","        }","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-05.swift","type":"file","fileType":"swift","highlights":[{"line":6},{"line":9},{"line":19},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35}]},"doc://MetaWear/documentation/MetaWear/MetaWear/updateRSSI()":{"role":"symbol","title":"updateRSSI()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"updateRSSI"},{"kind":"text","text":"()"}],"abstract":[{"type":"text","text":"Manually refreshes the peripheral’s RSSI if connected."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/updateRSSI()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/updaterssi()"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears":{"role":"project","title":"Connecting to MetaWears","estimatedTime":"10min","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","kind":"project","type":"topic","url":"\/tutorials\/metawear\/connecting-to-metawears"},"streamyIcon.png":{"alt":"Streamy app icon","type":"image","identifier":"streamyIcon.png","variants":[{"url":"\/images\/streamyIcon@2x.png","traits":["2x","light"]}]},"02-connecting-01-02.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","","    init(_ scanner: MetaWearScanner) {","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-02.swift","type":"file","fileType":"swift","highlights":[{"line":8},{"line":9},{"line":10},{"line":11},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20}]},"doc://MetaWear/documentation/MetaWear/MWCommand/macroEraseAll":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWMacro.EraseAll"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"macroEraseAll","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"macroEraseAll"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/macroEraseAll","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/macroeraseall"},"doc://MetaWear/documentation/MetaWear/MetaWear":{"role":"symbol","title":"MetaWear","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"MetaWear"}],"abstract":[{"type":"text","text":"Each MetaWear object corresponds a physical MetaWear board. This SDK"},{"type":"text","text":" "},{"type":"text","text":"wraps type-safe Swift methods and Combine publishers around C\/C++ functions"},{"type":"text","text":" "},{"type":"text","text":"and CoreBluetooth APIs so you can get started quickly."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MetaWear"}],"url":"\/documentation\/metawear\/metawear"},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data#Download-data":{"role":"pseudoSymbol","title":"Download data","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Download-data","kind":"section","type":"section","url":"\/tutorials\/metawear\/logging-sensor-data#Download-data"},"02-connecting-01-08.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","    private var knownSub:     AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.unknownDevices = $0.sorted() }","","        knownSub = sync?.knownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] metadata in","                self?.knownDevices = metadata","                    .sorted(using: KeyPathComparator(\\.name))","                    .map(\\.mac)","            }","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-08.swift","type":"file","fileType":"swift","highlights":[{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}]},"doc://MetaWear/documentation/MetaWear/MetaWear/publishWhenDisconnected()":{"role":"symbol","title":"publishWhenDisconnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishWhenDisconnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes after disconnection."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenDisconnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishwhendisconnected()"},"02-connecting-02-01.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    private weak var metawear: MetaWear?","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-01.swift","type":"file","fileType":"swift","highlights":[{"line":7}]},"02-connecting-03-04.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var identitySub:   AnyCancellable? = nil","","    ...","","    func onAppear() {","        trackIdentity()","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceController {","","    func trackIdentity() {","        identitySub = sync?.publisher(for: metadata.mac)","            .receive(on: DispatchQueue.main)","            .sink { [weak self] metawear, metadata in","                let metaWearReferenceNowAvailable = self?.metawear == nil && metawear != nil","                self?.metawear = metawear","                self?.metadata = metadata","","                if metaWearReferenceNowAvailable {","                    self?.trackRSSI()","                    self?.trackConnection()","                }","            }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-04.swift","type":"file","fileType":"swift","highlights":[{"line":29},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}]},"02-connecting-02-02.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","","    private weak var metawear: MetaWear?","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-02.swift","type":"file","fileType":"swift","highlights":[{"line":3},{"line":4},{"line":11}]},"doc://MetaWear/documentation/MetaWear/MetaWear/publishWhenConnected()":{"role":"symbol","title":"publishWhenConnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishWhenConnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes after connection and setup."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenConnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishwhenconnected()"},"doc://MetaWear/tutorials/MetaWear/Log-Sensor-Data":{"role":"article","title":"Log Sensor Data","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Log-Sensor-Data","kind":"article","type":"topic","url":"\/tutorials\/metawear\/log-sensor-data"},"02-connecting-02-04.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","","    private weak var metawear: MetaWear?","    private      var rssiSub:  AnyCancellable? = nil","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","        self.isCloudSynced = metadata != nil","        self.rssi = metawear.rssi","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-04.swift","type":"file","fileType":"swift","highlights":[{"line":5},{"line":8},{"line":16},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23}]},"02-connecting-03-02.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","    ","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var connectionSub: AnyCancellable? = nil","    private var rssiSub:       AnyCancellable? = nil","","    init(knownDevice: MACAddress, sync: MetaWearSyncStore) {","        self.sync = sync","        (self.metawear, self.metadata) = sync.getDeviceAndMetadata(knownDevice)!","        self.rssi = self.metawear?.rssi ?? -100","        self.connection = self.metawear?.connectionState ?? .disconnected","    }","","    func onAppear() {","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceController {","","    func trackRSSI() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func trackConnection() {","        connectionSub = metawear?.connectionStatePublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.connection = $0 }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-02.swift","type":"file","fileType":"swift","highlights":[{"line":3}]},"doc://MetaWear/documentation/MetaWear/MetaWear/connect()":{"role":"symbol","title":"connect()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"connect"},{"kind":"text","text":"()"}],"abstract":[{"type":"text","text":"Connect to this MetaWear and, if needed, initializes the C++ library."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connect()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/connect()"},"doc://MetaWear/documentation/MetaWear/MACAddress":{"role":"symbol","title":"MACAddress","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"MACAddress"}],"abstract":[{"type":"text","text":"A 6-byte unique identifier for a MetaWear and any Bluetooth device (e.g., F1:4A:45:90:AC:9D)"}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MACAddress"}],"url":"\/documentation\/metawear\/macaddress"},"02-connecting-03-08.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var resetSub:      AnyCancellable? = nil","","    ...","","    func reset() {","        resetSub = metawear?","            .publishWhenConnected()","            .first()","            .command(.resetActivities)","            .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","","        metawear?.connect()","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-08.swift","type":"file","fileType":"swift","highlights":[{"line":20},{"line":21}]},"02-connecting-02-03.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","","    private weak var metawear: MetaWear?","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","        self.isCloudSynced = metadata != nil","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-03.swift","type":"file","fileType":"swift","highlights":[{"line":4},{"line":13}]},"02-connecting-03-09.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var identifySub:   AnyCancellable? = nil","","    ...","","    func identify() {","        identifySub = metawear?.publishWhenConnected()","            .first()","            .command(.ledFlash(.Presets.one.pattern))","            .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","        if metawear?.connectionState ?? .disconnected < .connecting { metawear?.connect() }","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-09.swift","type":"file","fileType":"swift","highlights":[{"line":12},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22}]},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data":{"role":"project","title":"Logging Sensor Data","estimatedTime":"5min","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","kind":"project","type":"topic","url":"\/tutorials\/metawear\/logging-sensor-data"},"https://heckj.github.io/swiftui-notes/":{"title":"Joseph Heck’s guide","titleInlineContent":[{"type":"text","text":"Joseph Heck’s guide"}],"type":"link","identifier":"https:\/\/heckj.github.io\/swiftui-notes\/","url":"https:\/\/heckj.github.io\/swiftui-notes\/"},"doc://MetaWear/documentation/MetaWear/MetaWearScanner":{"role":"symbol","title":"MetaWearScanner","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"MetaWearScanner"}],"abstract":[{"type":"text","text":"Start scanning for MetaWear devices without having to understand all of CoreBluetooth. Pipelines return on the scanner’s unique "},{"type":"codeVoice","code":"bleQueue"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MetaWearScanner"}],"url":"\/documentation\/metawear\/metawearscanner"},"doc://MetaWear/tutorials/MetaWear/Discover-&-Connect":{"role":"article","title":"Discover & Connect","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect","kind":"article","type":"topic","url":"\/tutorials\/metawear\/discover-&-connect"},"02-connecting-01-07.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","    private var knownSub:     AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.unknownDevices = $0.sorted() }","","        knownSub = sync?.knownDevices","            .receive(on: DispatchQueue.main)","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-07.swift","type":"file","fileType":"swift","highlights":[{"line":13},{"line":29},{"line":30},{"line":31}]},"02-connecting-03-07.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var resetSub:      AnyCancellable? = nil","","    ...","","    func reset() {","        resetSub = metawear?","            .publishWhenConnected()","            .first()","        ","","        metawear?.connect()","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-07.swift","type":"file","fileType":"swift","highlights":[{"line":12},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}]},"doc://MetaWear/documentation/MetaWear/MetaWear/publishIfConnected()":{"role":"symbol","title":"publishIfConnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishIfConnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"MWPublisher","preciseIdentifier":"s:8MetaWear11MWPublishera"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes if connected and setup at start, failing if not."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishIfConnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishifconnected()"},"Streamy.zip":{"checksum":"685fd06a76d72ed2f5663062b12da1a5db31bf221aaf21461557f448f689566844b9e978c508ff59346d8afed8ae3258e4fb37b1a9bf79f84ddc3fb4f5057946","type":"download","identifier":"Streamy.zip","url":"\/downloads\/Streamy.zip"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#Managing-known-devices":{"role":"pseudoSymbol","title":"Managing known devices","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#Managing-known-devices","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#Managing-known-devices"},"doc://MetaWear/tutorials/MetaWear/Using-a-CoreML-Model#Forthcoming":{"role":"pseudoSymbol","title":"Forthcoming","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model#Forthcoming","kind":"section","type":"section","url":"\/tutorials\/metawear\/using-a-coreml-model#Forthcoming"},"doc://MetaWear/tutorials/MetaWear/Training-Activity-Classification#Forthcoming":{"role":"pseudoSymbol","title":"Forthcoming","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification#Forthcoming","kind":"section","type":"section","url":"\/tutorials\/metawear\/training-activity-classification#Forthcoming"},"02-connecting-02-07.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var isConnecting = false","","    private weak var metawear: MetaWear?","    private weak var sync:     MetaWearSyncStore?","    private weak var parent:   DeviceListController?","    private      var rssiSub:  AnyCancellable? = nil","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore,","         parent: DeviceListController) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","        self.isCloudSynced = metadata != nil","        self.rssi = metawear.rssi","        self.sync = sync","        self.parent = parent","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID else { return }","        isConnecting = true","","        sync?.connectAndRemember(unknown: id, didAdd: { [weak self] (device, _) in","            guard let parent = self?.parent else { return }","            device?.publishIfConnected()","                .command(.ledFlash(.Presets.one.pattern))","                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","                .store(in: &parent.childDidAddDeviceSubs)","        })","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-07.swift","type":"file","fileType":"swift","highlights":[{"line":10},{"line":14},{"line":15},{"line":22},{"line":35},{"line":36},{"line":40}]},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project#Add-MetaWear-and-MetaWearSync":{"role":"pseudoSymbol","title":"Add MetaWear and MetaWearSync","abstract":[{"type":"text","text":"This tutorial guides you through building "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", an app to capture and analyze motion sensor data."},{"type":"text","text":" "},{"type":"text","text":"You’ll start by adding the MetaWear SDK using Swift Package Manager and then link up dependencies."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Add-MetaWear-and-MetaWearSync","kind":"section","type":"section","url":"\/tutorials\/metawear\/adding-metawear-to-a-project#Add-MetaWear-and-MetaWearSync"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#List-nearby-devices":{"role":"pseudoSymbol","title":"List nearby devices","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#List-nearby-devices","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#List-nearby-devices"},"doc://MetaWear/documentation/MetaWear/MWCommand/resetFactoryDefaults":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWFactoryReset"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"resetFactoryDefaults","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"resetFactoryDefaults"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Wipes any data and settings from the MetaWear."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetFactoryDefaults","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/resetfactorydefaults"},"02-connecting-01-06.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.unknownDevices = $0.sorted() }","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-06.swift","type":"file","fileType":"swift","highlights":[{"line":27}]},"02-connecting-01-04.swift":{"syntax":"swift","content":["import MetaWear","import Combine","","class DeviceListController: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices: [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension NearbyDeviceListController {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","    ","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-04.swift","type":"file","fileType":"swift","highlights":[{"line":2},{"line":10},{"line":11},{"line":13},{"line":14},{"line":23},{"line":24},{"line":25}]},"doc://MetaWear/documentation/MetaWear/MWCommand/resetActivities":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWActivitiesReset"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"resetActivities","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"resetActivities"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Removes all data processors, loggers, timers, and recorded events from"},{"type":"text","text":" "},{"type":"text","text":"both the board and the struct’s internal state. The board itself is not reset,"},{"type":"text","text":" "},{"type":"text","text":"so any configuration changes will be preserved."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetActivities","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/resetactivities"},"doc://MetaWear/documentation/MetaWear/CBPeripheralIdentifier":{"role":"symbol","title":"CBPeripheralIdentifier","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBPeripheralIdentifier"}],"abstract":[{"type":"text","text":"While stable locally, Apple identifies CoreBluetooth peripherals via a UUID that differs between a user’s phones and computers. Once connected, a MetaWear’s `MetaWear\/MetaWear\/info`` property exposes the stable MAC address, as does our advertising packet when seen via Android."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/CBPeripheralIdentifier","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBPeripheralIdentifier"}],"url":"\/documentation\/metawear\/cbperipheralidentifier"},"doc://MetaWear/documentation/MetaWear/MWCommand/restart":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWRestart"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"restart","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"restart"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Restarts, preserving macros, loggers, and settings,"},{"type":"text","text":" "},{"type":"text","text":"but any in-memory activities are lost."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/restart","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/restart"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#First-connection":{"role":"pseudoSymbol","title":"First connection","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#First-connection","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#First-connection"},"02-connecting-03-01.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","    private var connectionSub: AnyCancellable? = nil","    private var rssiSub:       AnyCancellable? = nil","","    init(knownDevice: MACAddress, sync: MetaWearSyncStore) {","        self.sync = sync","        (self.metawear, self.metadata) = sync.getDeviceAndMetadata(knownDevice)!","        self.rssi = self.metawear?.rssi ?? -100","        self.connection = self.metawear?.connectionState ?? .disconnected","    }","","    func onAppear() {","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceController {","","    func trackRSSI() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func trackConnection() {","        connectionSub = metawear?.connectionStatePublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.connection = $0 }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-01.swift","type":"file","fileType":"swift","highlights":[{"line":4},{"line":8},{"line":15},{"line":20},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}]},"doc://MetaWear/documentation/MetaWear/MetaWear/bleQueue":{"role":"symbol","title":"bleQueue","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"bleQueue"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"DispatchQueue","preciseIdentifier":"c:objc(cs)OS_dispatch_queue"}],"abstract":[{"type":"text","text":"To prevent crashes, use this queue for all MetaWearCpp library calls."},{"type":"text","text":" "},{"type":"text","text":"All SDK publishers subscribe and return on this queue unless stated."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/bleQueue","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/blequeue"},"02-connecting-03-10.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","    @Published var showRenamePrompt = false","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","","    ...","","    func rename(_ newName: String) {","        do { try sync?.rename(known: metadata, to: newName) }","        catch { showRenamePrompt = true }","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-10.swift","type":"file","fileType":"swift","highlights":[{"line":9},{"line":16},{"line":17},{"line":18}]},"doc://MetaWear/documentation/MetaWear/MWLED/Flash/Pattern/Emulator":{"role":"symbol","title":"MWLED.Flash.Pattern.Emulator","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Emulator"}],"abstract":[{"type":"text","text":"Load your own pattern and call "},{"type":"codeVoice","code":"emulate"},{"type":"text","text":" to recreate the MetaWear’s LED behavior"},{"type":"text","text":" "},{"type":"text","text":"in a SwiftUI view or by subscribing to the "},{"type":"codeVoice","code":"ledIsOnPublisher"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWLED\/Flash\/Pattern\/Emulator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Emulator"}],"url":"\/documentation\/metawear\/mwled\/flash\/pattern\/emulator"},"doc://MetaWear/documentation/MetaWear/MetaWear/rssiPublisher":{"role":"symbol","title":"rssiPublisher","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"rssiPublisher"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Most recent RSSI, as pushed from an active "},{"type":"codeVoice","code":"MetaWearScanner"},{"type":"text","text":" or from "},{"type":"codeVoice","code":"CBPeripheralDelegate"},{"type":"text","text":" about every 5 seconds by automatic calls to "},{"type":"codeVoice","code":"updateRSSI()"},{"type":"text","text":" (only while connected). -100  can indicate disconnection."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/rssipublisher"},"doc://MetaWear/tutorials/MetaWear":{"role":"overview","title":"From Zero to Machine Learning","abstract":[{"type":"text","text":"Control MetaWear wearable sensors to classify movement. Let’s build "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", a barebones app using "},{"type":"codeVoice","code":"Swift"},{"type":"text","text":", "},{"type":"codeVoice","code":"Combine"},{"type":"text","text":", "},{"type":"codeVoice","code":"CoreML"},{"type":"text","text":", and "},{"type":"codeVoice","code":"SwiftUI"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear","kind":"overview","type":"topic","url":"\/tutorials\/metawear"},"02-connecting-03-06.swift":{"syntax":"swift","content":["class KnownDeviceController: ObservableObject {","","    var name: String { metadata.name }","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","    @Published private var metadata: MetaWearMetadata","","    private weak var metawear: MetaWear? = nil","    private weak var sync:     MetaWearSyncStore?","","    ...","","    func connect() {","        metawear?.connect()","    }","","    func disconnect() {","        metawear?.disconnect()","    }","","    func forget() {","        sync?.forget(globally: metadata)","    }","}","","private extension KnownDeviceController {","    ...","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-06.swift","type":"file","fileType":"swift","highlights":[{"line":3},{"line":4},{"line":5},{"line":8},{"line":22},{"line":23},{"line":24},{"line":25}]},"02-connecting-02-06.swift":{"syntax":"swift","content":["class UnknownDeviceController: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var isConnecting = false","","    private weak var metawear: MetaWear?","    private weak var sync:     MetaWearSyncStore?","    private      var rssiSub:  AnyCancellable? = nil","","    init(id: CBPeripheralIdentifier,","         sync: MetaWearSyncStore) {","        let (device, metadata) = sync.getDevice(byLocalCBUUID: id)","        self.metawear = device","        self.name = metadata?.name ?? device!.name","        self.isCloudSynced = metadata != nil","        self.rssi = metawear.rssi","        self.sync = sync","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID else { return }","        isConnecting = true","","        sync?.connectAndRemember(unknown: id, didAdd: { (device, _) in","            device?.publishIfConnected()","                .command(.ledFlash(.Presets.one.pattern))","                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","               ","        })","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-06.swift","type":"file","fileType":"swift","highlights":[{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37}]},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project#Swift-Package-Manager":{"role":"pseudoSymbol","title":"Swift Package Manager","abstract":[{"type":"text","text":"This tutorial guides you through building "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", an app to capture and analyze motion sensor data."},{"type":"text","text":" "},{"type":"text","text":"You’ll start by adding the MetaWear SDK using Swift Package Manager and then link up dependencies."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Swift-Package-Manager","kind":"section","type":"section","url":"\/tutorials\/metawear\/adding-metawear-to-a-project#Swift-Package-Manager"},"doc://MetaWear/tutorials/MetaWear/Using-a-CoreML-Model":{"role":"project","title":"Using a CoreML Model","estimatedTime":"20min","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model","kind":"project","type":"topic","url":"\/tutorials\/metawear\/using-a-coreml-model"}}}