{"metadata":{"title":"Connecting to MetaWears","categoryPathComponent":"MetaWear","role":"project","category":"MetaWear"},"hierarchy":{"modules":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Whats-Ahead"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Swift-Package-Manager-&-Permissions"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#The-Core-SDK-Classes"}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#List-nearby-devices"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#First-connection"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#Managing-known-devices"}]}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Log-Sensor-Data","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#To-Log-or-Download?"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Configure-logging-commands"},{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Download-data"}]}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Train-a-CoreML-Model","projects":[{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification#Collecting-Training-Data"}]},{"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model","sections":[{"kind":"task","reference":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model#Forthcoming"}]}]}],"reference":"doc:\/\/MetaWear\/tutorials\/MetaWear","paths":[["doc:\/\/MetaWear\/tutorials\/MetaWear","doc:\/\/MetaWear\/tutorials\/MetaWear\/$volume","doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect"]]},"schemaVersion":{"major":0,"minor":1,"patch":0},"kind":"project","identifier":{"url":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","interfaceLanguage":"swift"},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}]}],"estimatedTimeInMinutes":15,"title":"Connecting to MetaWears","image":"streamyIcon.png","chapter":"Discover & Connect","kind":"hero","backgroundImage":"streamyIcon.png","projectFiles":"Streamy.zip"},{"kind":"tasks","tasks":[{"anchor":"List-nearby-devices","title":"List nearby devices","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Listing MetaWears on iOS requires a little more flexibility than Android. For privacy reasons, Apple prevents inspection of a peripheral’s MAC address until first connection."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s build a data source object for a table view that lists both novel and known devices."}]}],"mediaPosition":"trailing","media":"bird-green-yellow.png"}],"stepsSection":[{"code":"02-connecting-01-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Before first connection, a MetaWear can only be identified by a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/CBPeripheralIdentifier"},{"type":"text","text":"  "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" provided by "},{"type":"codeVoice","code":"CoreBluetooth"},{"type":"text","text":". Apple randomizes these ids between host machines, so they are meaningful only locally."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Once connected, a MetaWear populates its "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress"},{"type":"text","text":" in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/info"},{"type":"text","text":" property and archives its UUID and MAC in local UserDefaults. If you use the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":" (as we will in this tutorial), the SDK will update iCloud key value storage to sync MetaWear identities, including groupings of MetaWears, across machines."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To surface nearby devices, we’ll ask the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":" to prod CoreBluetooth to scan for nearby devices."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Tip"}]},{"type":"text","text":" This will also create MetaWear instances for previously locally used devices, even if they aren’t yet seen nearby."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Scanning consumes energy. Stop scanning when there isn’t UI to handle new discoveries."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"higherPerformanceMode"},{"type":"text","text":" option speeds up new discoveries, but uses more energy. CoreBluetooth calls this option the "},{"type":"codeVoice","code":"CBCentralManagerScanOptionAllowDuplicatesKey"},{"type":"text","text":". If Bluetooth is powered off, the scan request won’t kickoff until Bluetooth is on. For an example of handling state and authorization, see "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":"’s "},{"type":"codeVoice","code":"BluetoothUseCase"},{"type":"text","text":"."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As new nearby MetaWears are discovered, the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":" will publish an array of local "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" identifiers."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Apple’s Combine framework"}]},{"type":"text","text":" is how this SDK reasons about asynchronous events and value streams. To learn more, we suggest "},{"type":"reference","isActive":true,"identifier":"https:\/\/heckj.github.io\/swiftui-notes\/"},{"type":"text","text":". To summarize Combine briefly, a Publisher emits values over time, either forever or terminating with a success or failure. To subscribe a Publisher’s output and keep this subscription in memory, you must call an operator like "},{"type":"codeVoice","code":".sink"},{"type":"text","text":". This returns a token, fancily named an "},{"type":"codeVoice","code":"AnyCancellable"},{"type":"text","text":". It is a class that you can house individually or in a Set. This token will nil out and tear down the pipeline when your object deallocates, you replace the token with another, the pipeline finishes, or you call "},{"type":"codeVoice","code":".cancel()"},{"type":"text","text":". Before subscribing via "},{"type":"codeVoice","code":".sink"},{"type":"text","text":", a pipeline is an inert recipe that you can pass around to construct in stages."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Our "},{"type":"codeVoice","code":"DeviceListUseCase"},{"type":"text","text":" will drive a table view, so let’s do updates on the main queue. The highlighted line is equivalent to calling "},{"type":"codeVoice","code":"DispatchQueue.main.async"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Thread Safety"}]},{"type":"text","text":"  This SDK’s Publishers and objects all run and output on a serial DispatchQueue used by the underlying C\/C++ library. You can find this queue on all SDK classes, such as the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/bleQueue"},{"type":"text","text":" property on a MetaWear."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s subscribe to the pipeline with "},{"type":"codeVoice","code":"sink"},{"type":"text","text":". Before updating the "},{"type":"codeVoice","code":"unknownDevices"},{"type":"text","text":" array, we’ll sort IDs for stability."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As with any closure, to prevent retain cycles, weakify the capture list."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we’ll listen for the latest metadata of previously used MetaWears, including those used only on other host machines. iCloud might take a moment to share remote updates."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-01-08.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ll keep only the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress"},{"type":"text","text":" after sorting by device name for stability."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"First-connection","title":"First connection","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A nearby device’s table view cell needs its advertised Bluetooth name, signal strength, and connection intent."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After connecting to a new device, flashing the device’s LEDs and replicating that pattern on screen would make it easy to identify that MetaWear from a pile of others."}]}],"mediaPosition":"trailing","media":"bird-teal.png"}],"stepsSection":[{"code":"02-connecting-02-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" example app, the factory that creates this use case already obtained a reference to the nearby MetaWear of interest by asking the sync store about a particular UUID."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The sync store obtains this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear"},{"type":"text","text":" reference from the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":". It also tries to match it with additional metadata."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ll try to retrieve a name from iCloud synced-metadata, if available, and fall back to the MetaWear’s Bluetooth advertised name."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Edge Case"}]},{"type":"text","text":" If a user asks to “forget” a MetaWear just for the local machine, but not others, it might be nice to show an iCloud icon to reassure this action completed as expected."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Until the app closes, the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":" and the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/info"},{"type":"text","text":" property will retain some information. A truly novel device’s metadata will be nil."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To depict signal strength, we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Updates occur in three scenarios. (1) While "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":" is actively scanning. (2) Explicitly by calling "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/updateRSSI()"},{"type":"text","text":". (3) Implicitly by subscribing to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher"},{"type":"text","text":", which ensures at least one update occurs every 5 seconds until unsubscribed."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Offering a “remember device” action means we need a reference to the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When it successfully connects and catalogs the device, a callback provides the connected MetaWear and its metadata for temporary use."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s use that callback to flash the LEDs on the MetaWear. We’ll ask the MetaWear to kickoff a Combine pipeline, then issue our command. For brevity, we’ll choose one of the color\/pattern presets."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWLED\/Flash\/Pattern\/Emulator"},{"type":"text","text":" can drive UI that mimics the flash command. For an example use of the emulator, see the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/mbientlab\/mbientSwiftUI\/blob\/52350efd57865ee4f7ac982293fb3e356b1c48c8\/Sources\/mbientSwiftUI\/Device\/MetaWearWithLED.swift"},{"type":"text","text":" repo."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-02-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"One problem. Without waiting for this closure, the sync store will publish a shorter list of unknown devices that lacks this particular MetaWear. This table view might deallocate this use case before the LED command completes!"}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this barebones app, our fix is to deposit the token for this LED pipeline in an external object (on the parent ListUseCase)."}]}],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"Managing-known-devices","title":"Managing known devices","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ll issue commands like rename, reset, or forget."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Also on the docket is handling scenarios in which a MetaWear is initially known only from iCloud-synced metadata, but later on the user discovers it locally or CoreBluetooth belatedly delivers an instance of it."}]}],"mediaPosition":"trailing","media":"bird-blue.png"}],"stepsSection":[{"code":"02-connecting-03-00.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", the factory that created this use case asked the sync store for anything it had on a particular MAC address at that moment in time."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The MetaWear reference will be nil if the local machine has never connected to this device or if CoreBluetooth is not on or authorized. Regardless, the cloud-synced metadata will include the device’s name, model, serial number, and specifics on its sensors."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-01.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the MetaWear reference isn’t available, our UI can show an iCloud glyph."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As we connect and disconnect from this device, we can reflect progress by rebroadcasting the MetaWear’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connectionStatePublisher"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Tip"}]},{"type":"text","text":" The SDK conforms "},{"type":"codeVoice","code":"CBPeripheralState"},{"type":"text","text":" to Comparable so you can use logic like "},{"type":"codeVoice","code":"<"},{"type":"text","text":" or "},{"type":"codeVoice","code":"..<"},{"type":"text","text":"."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-03.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If we started with a nil MetaWear, the connection publisher above will never construct."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To solve scenarios where we belately receive a MetaWear reference, we can simply ask the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":" for a publisher tracking this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress"},{"type":"text","text":". We’ll be told of any metadata changes or when an instance becomes available."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-04.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"At this point, we can safely start the RSSI and connection pipelines that did not construct back in "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":"."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-05.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A connect or disconnect command is simple."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-06.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To forget devices, use the sync store."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"While the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner"},{"type":"text","text":" has a forget command, it won’t inform the "},{"type":"codeVoice","code":"MetaWearSyncStore"},{"type":"text","text":". The sync store will be, ahem, out of sync."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-07.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To reset a MetaWear, let’s issue a one-time command. The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenConnected()"},{"type":"text","text":" publisher fires every time a MetaWear connects. What a hostile reset button that could be! Using "},{"type":"codeVoice","code":".first()"},{"type":"text","text":" will stop after one connection event."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Since this MetaWear may not yet be connected, we need to call "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connect()"},{"type":"text","text":". Creating a pipeline and then calling "},{"type":"codeVoice","code":".connect()"},{"type":"text","text":" is a pattern we’ll repeat often. Other publishers include "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenDisconnected()"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishIfConnected()"},{"type":"text","text":", which fails if not connected."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-08.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Our reset will have two parts. First, we’ll delete any logged data. We’ll then chain a command that wipes active loggers or event triggers."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"TL;DR"}]},{"type":"text","text":" Resets come in gradations of severity: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetFactoryDefaults"},{"type":"text","text":" nukes everything (including logged data), "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetActivities"},{"type":"text","text":" strips macros or loggers but not settings or data, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/macroEraseAll"},{"type":"text","text":" strips just macros, and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/restart"},{"type":"text","text":" preserves macros, loggers and settings, but purges in-memory activities. If your MetaWear crashes on connect, use the factory reset to break the bad state caused by a faulty command or Bluetooth hiccup."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"02-connecting-03-09.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, let’s ask the sync store to rename a MetaWear. Providing a name that’s too long or contains invalid characters will throw an error."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]}]},{"action":{"overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"isActive":true,"type":"reference","identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","kind":"callToAction","title":"Logging Sensor Data","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}]}],"references":{"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#Managing-known-devices":{"role":"pseudoSymbol","title":"Managing known devices","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#Managing-known-devices","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#Managing-known-devices"},"doc://MetaWear/tutorials/MetaWear/Train-a-CoreML-Model":{"role":"article","title":"Train a CoreML Model","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Train-a-CoreML-Model","kind":"article","type":"topic","url":"\/tutorials\/metawear\/train-a-coreml-model"},"doc://MetaWear/documentation/MetaWear/MetaWear/publishIfConnected()":{"role":"symbol","title":"publishIfConnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishIfConnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"MWPublisher","preciseIdentifier":"s:8MetaWear11MWPublishera"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes if connected and setup at start, failing if not."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishIfConnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishifconnected()"},"02-connecting-03-06.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    ...","","}","","extension KnownDeviceUseCase {","","    func connect() {","        metawear?.connect()","    }","","    func disconnect() {","        metawear?.disconnect()","    }","","    func forget() {","        sync?.forget(globally: metadata)","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-06.swift","type":"file","fileType":"swift","highlights":[{"line":23},{"line":24},{"line":25},{"line":26}]},"doc://MetaWear/documentation/MetaWear/MetaWear/publishWhenConnected()":{"role":"symbol","title":"publishWhenConnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishWhenConnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes after connection and setup."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenConnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishwhenconnected()"},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data#Configure-logging-commands":{"role":"pseudoSymbol","title":"Configure logging commands","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Configure-logging-commands","kind":"section","type":"section","url":"\/tutorials\/metawear\/logging-sensor-data#Configure-logging-commands"},"02-connecting-03-07.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    ...","","}","","extension KnownDeviceUseCase {","","    func resetDeletingLogs() {","        resetSub = metawear?","            .publishWhenConnected()","            .first()","","","        metawear?.connect()","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-07.swift","type":"file","fileType":"swift","highlights":[{"line":16},{"line":17},{"line":18},{"line":19},{"line":22}]},"02-connecting-01-04.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-04.swift","type":"file","fileType":"swift","highlights":[{"line":2},{"line":3},{"line":11},{"line":12},{"line":14},{"line":15},{"line":24},{"line":25},{"line":26}]},"02-connecting-02-04.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","","    private weak var metawear:  MetaWear?","    private      var rssiSub:   AnyCancellable? = nil","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?)) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","        self.isCloudSynced = nearby.metadata?.hasCloudSyncedInfo == true","        self.rssi = nearby.metawear.rssi","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .onMain()","            .sink { [weak self] in self?.rssi = $0 }","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-04.swift","type":"file","fileType":"swift","highlights":[{"line":5},{"line":8},{"line":14},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}]},"02-connecting-01-07.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","    private var knownSub:     AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] ids in self?.unknownDevices = ids.sorted() }","","        knownSub = sync?.knownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] metadata in","                self?.knownDevices = metadata","                ...","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-07.swift","type":"file","fileType":"swift","highlights":[{"line":13},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}]},"doc://MetaWear/documentation/MetaWear/MetaWear/connectionStatePublisher":{"role":"symbol","title":"connectionStatePublisher","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"connectionStatePublisher"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"CBPeripheralState","preciseIdentifier":"c:@E@CBPeripheralState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Stream of connecting, connected (and with C++ library setup), disconnecting, and disconnected events."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connectionStatePublisher","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/connectionstatepublisher"},"doc://MetaWear/documentation/MetaWear/MetaWear/publishWhenDisconnected()":{"role":"symbol","title":"publishWhenDisconnected()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"publishWhenDisconnected"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Publishes after disconnection."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/publishWhenDisconnected()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/publishwhendisconnected()"},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data#To-Log-or-Download?":{"role":"pseudoSymbol","title":"To Log or Download?","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#To-Log-or-Download?","kind":"section","type":"section","url":"\/tutorials\/metawear\/logging-sensor-data#To-Log-or-Download?"},"Streamy.zip":{"checksum":"37d02e914436e3be7cad8b6278697ae323af5f0ce941dab5d9005a05c34e347fd37e54c1f12c401aba55671a33667f73311abcb237050010942dcc5cdd956a25","type":"download","identifier":"Streamy.zip","url":"\/downloads\/Streamy.zip"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears":{"role":"project","title":"Connecting to MetaWears","estimatedTime":"15min","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears","kind":"project","type":"topic","url":"\/tutorials\/metawear\/connecting-to-metawears"},"02-connecting-01-02.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","","    init(_ scanner: MetaWearScanner) {","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-02.swift","type":"file","fileType":"swift","highlights":[{"line":8},{"line":9},{"line":10},{"line":11},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20}]},"doc://MetaWear/documentation/MetaWear/MetaWear/updateRSSI()":{"role":"symbol","title":"updateRSSI()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"updateRSSI"},{"kind":"text","text":"()"}],"abstract":[{"type":"text","text":"Manually refreshes the peripheral’s RSSI if connected."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/updateRSSI()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/updaterssi()"},"doc://MetaWear/tutorials/MetaWear/Using-a-CoreML-Model#Forthcoming":{"role":"pseudoSymbol","title":"Forthcoming","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model#Forthcoming","kind":"section","type":"section","url":"\/tutorials\/metawear\/using-a-coreml-model#Forthcoming"},"02-connecting-01-08.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","    private var knownSub:     AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] ids in self?.unknownDevices = ids.sorted() }","","        knownSub = sync?.knownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] metadata in","                self?.knownDevices = metadata","                    .sorted(using: KeyPathComparator(\\.name))","                    .map(\\.mac)","            }","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-08.swift","type":"file","fileType":"swift","highlights":[{"line":34},{"line":35},{"line":36}]},"doc://MetaWear/tutorials/MetaWear/Using-a-CoreML-Model":{"role":"project","title":"Using a CoreML Model","estimatedTime":"15min","abstract":[{"type":"text","text":"Forthcoming."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Using-a-CoreML-Model","kind":"project","type":"topic","url":"\/tutorials\/metawear\/using-a-coreml-model"},"doc://MetaWear/documentation/MetaWear/MetaWear/info":{"role":"symbol","title":"info","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"info"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"MetaWear","preciseIdentifier":"c:@M@MetaWear@objc(cs)MetaWear"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"DeviceInformation","preciseIdentifier":"s:8MetaWearAAC17DeviceInformationV"}],"abstract":[{"type":"text","text":"MAC address, model, serial, firmware, hardware details. "},{"type":"strong","inlineContent":[{"type":"text","text":"Populated after connection, but the MAC address may be available immediately for remembered devices."}]}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/info","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/info"},"02-connecting-01-01.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    init() {","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-01.swift","type":"file","fileType":"swift","highlights":[]},"doc://MetaWear/documentation/MetaWear/MetaWearScanner":{"role":"symbol","title":"MetaWearScanner","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"MetaWearScanner"}],"abstract":[{"type":"text","text":"Start scanning for MetaWear devices without having to understand all of CoreBluetooth. Pipelines return on the scanner’s unique "},{"type":"codeVoice","code":"bleQueue"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWearScanner","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MetaWearScanner"}],"url":"\/documentation\/metawear\/metawearscanner"},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project#The-Core-SDK-Classes":{"role":"pseudoSymbol","title":"The Core SDK Classes","abstract":[{"type":"text","text":"This tutorial examines the dependencies and permissions needed for the SDK."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#The-Core-SDK-Classes","kind":"section","type":"section","url":"\/tutorials\/metawear\/adding-metawear-to-a-project#The-Core-SDK-Classes"},"doc://MetaWear/documentation/MetaWear/MWCommand/resetActivities":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWActivitiesReset"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"resetActivities","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"resetActivities"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"MWActivitiesReset","preciseIdentifier":"s:8MetaWear17MWActivitiesResetV"}],"abstract":[{"type":"text","text":"Removes all data processors, loggers, timers, and recorded events from"},{"type":"text","text":" "},{"type":"text","text":"both the board and the struct’s internal state. The board itself is not reset,"},{"type":"text","text":" "},{"type":"text","text":"so any configuration changes will be preserved."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetActivities","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/resetactivities"},"02-connecting-02-03.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","","    private weak var metawear:  MetaWear?","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?)) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","        self.isCloudSynced = nearby.metadata?.hasCloudSyncedInfo == true","    }","","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-03.swift","type":"file","fileType":"swift","highlights":[{"line":4},{"line":11}]},"doc://MetaWear/documentation/MetaWear/CBPeripheralIdentifier":{"role":"symbol","title":"CBPeripheralIdentifier","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBPeripheralIdentifier"}],"abstract":[{"type":"text","text":"While stable locally, Apple identifies CoreBluetooth peripherals via a UUID that differs between a user’s phones and computers. Once connected, a MetaWear’s `MetaWear\/MetaWear\/info`` property exposes the stable MAC address, as does our advertising packet when seen via Android."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/CBPeripheralIdentifier","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBPeripheralIdentifier"}],"url":"\/documentation\/metawear\/cbperipheralidentifier"},"https://heckj.github.io/swiftui-notes/":{"title":"Joseph Heck’s guide","titleInlineContent":[{"type":"text","text":"Joseph Heck’s guide"}],"type":"link","identifier":"https:\/\/heckj.github.io\/swiftui-notes\/","url":"https:\/\/heckj.github.io\/swiftui-notes\/"},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data#Download-data":{"role":"pseudoSymbol","title":"Download data","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data#Download-data","kind":"section","type":"section","url":"\/tutorials\/metawear\/logging-sensor-data#Download-data"},"02-connecting-02-05.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear:  MetaWear?","    private weak var sync:      MetaWearSyncStore?","    private      var rssiSub:   AnyCancellable? = nil","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?),","         sync:   MetaWearSyncStore) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","        self.isCloudSynced = nearby.metadata?.hasCloudSyncedInfo == true","        self.rssi = nearby.metawear.rssi","        self.connection = nearby.metawear.connectionState","        self.sync = sync","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .onMain()","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID,","              let sync = sync","        else { return }","        self.connection = .connecting","        sync?.connectAndRemember(unknown: id, didAdd: { (device, metadata) in","            ","        })","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-05.swift","type":"file","fileType":"swift","highlights":[{"line":6},{"line":9},{"line":12},{"line":13},{"line":18},{"line":19},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}]},"doc://MetaWear/documentation/MetaWear/MWLED/Flash/Pattern/Emulator":{"role":"symbol","title":"MWLED.Flash.Pattern.Emulator","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Emulator"}],"abstract":[{"type":"text","text":"Load your own pattern and call "},{"type":"codeVoice","code":"emulate"},{"type":"text","text":" to recreate the MetaWear’s LED behavior"},{"type":"text","text":" "},{"type":"text","text":"in a SwiftUI view or by subscribing to the "},{"type":"codeVoice","code":"ledIsOnPublisher"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWLED\/Flash\/Pattern\/Emulator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Emulator"}],"url":"\/documentation\/metawear\/mwled\/flash\/pattern\/emulator"},"02-connecting-02-02.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","","    private weak var metawear:  MetaWear?","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?)) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","    }","","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-02.swift","type":"file","fileType":"swift","highlights":[{"line":3},{"line":4},{"line":9}]},"02-connecting-02-06.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear:  MetaWear?","    private weak var sync:      MetaWearSyncStore?","    private      var rssiSub:   AnyCancellable? = nil","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?),","         sync:   MetaWearSyncStore) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","        self.isCloudSynced = nearby.metadata?.localBluetoothIds.isEmpty == false","        self.rssi = nearby.metawear.rssi","        self.connection = nearby.metawear.connectionState","        self.sync = sync","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .onMain()","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID,","              let sync = sync","        else { return }","        self.connection = .connecting","        sync?.connectAndRemember(unknown: id, didAdd: { (device, metadata) in","            device?.publishIfConnected()","                .command(.ledFlash(.Presets.one.pattern))","                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","        })","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-06.swift","type":"file","fileType":"swift","highlights":[{"line":16},{"line":34},{"line":35},{"line":36}]},"02-connecting-03-00.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","","    private weak var metawear: MetaWear?","    private var rssiSub:       AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore,","         _ known: (device: MetaWear?, metadata: MetaWearMetadata)) {","        self.sync = sync","        (self.metawear, self.metadata) = known","        self.rssi = self.metawear?.rssi ?? -100","    }","","    func onAppear {","        trackRSSI()","    }","","}","","\/\/ * Called by the factory object creating the use case *","","class MetaWearSyncStore {","","    func getDeviceAndMetadata(_ mac: MACAddress)","    -> (device: MetaWear?, metadata: MetaWearMetadata)?","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-00.swift","type":"file","fileType":"swift","highlights":[{"line":12},{"line":26},{"line":27}]},"bird-blue.png":{"alt":"Bird art","type":"image","identifier":"bird-blue.png","variants":[{"url":"\/images\/bird-blue@1x.png","traits":["1x","light"]}]},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project#Whats-Ahead":{"role":"pseudoSymbol","title":"What's Ahead","abstract":[{"type":"text","text":"This tutorial examines the dependencies and permissions needed for the SDK."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Whats-Ahead","kind":"section","type":"section","url":"\/tutorials\/metawear\/adding-metawear-to-a-project#Whats-Ahead"},"doc://MetaWear/documentation/MetaWear/MetaWear/bleQueue":{"role":"symbol","title":"bleQueue","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"bleQueue"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"DispatchQueue","preciseIdentifier":"c:objc(cs)OS_dispatch_queue"}],"abstract":[{"type":"text","text":"To prevent crashes, use this queue for all MetaWearCpp library calls."},{"type":"text","text":" "},{"type":"text","text":"All SDK publishers subscribe and return on this queue unless stated."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/bleQueue","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/blequeue"},"doc://MetaWear/documentation/MetaWear/MACAddress":{"role":"symbol","title":"MACAddress","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"MACAddress"}],"abstract":[{"type":"text","text":"A 6-byte unique identifier for a MetaWear and any Bluetooth device (e.g., F1:4A:45:90:AC:9D)"}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MACAddress","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MACAddress"}],"url":"\/documentation\/metawear\/macaddress"},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project#Swift-Package-Manager-&-Permissions":{"role":"pseudoSymbol","title":"Swift Package Manager & Permissions","abstract":[{"type":"text","text":"This tutorial examines the dependencies and permissions needed for the SDK."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project#Swift-Package-Manager-&-Permissions","kind":"section","type":"section","url":"\/tutorials\/metawear\/adding-metawear-to-a-project#Swift-Package-Manager-&-Permissions"},"02-connecting-01-03.swift":{"syntax":"swift","content":["import MetaWear","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","","    init(_ scanner: MetaWearScanner) {","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-03.swift","type":"file","fileType":"swift","highlights":[{"line":20},{"line":21},{"line":22},{"line":23}]},"doc://MetaWear/documentation/MetaWear/MWCommand/macroEraseAll":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWMacro.EraseAll"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"macroEraseAll","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"macroEraseAll"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"MWMacro","preciseIdentifier":"s:8MetaWear7MWMacroV"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"EraseAll","preciseIdentifier":"s:8MetaWear7MWMacroV8EraseAllV"}],"abstract":[],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/macroEraseAll","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/macroeraseall"},"02-connecting-03-05.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    ...","","}","","extension KnownDeviceUseCase {","","    func connect() {","        metawear?.connect()","    }","","    func disconnect() {","        metawear?.disconnect()","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-05.swift","type":"file","fileType":"swift","highlights":[{"line":16},{"line":17},{"line":18},{"line":20},{"line":21},{"line":22}]},"02-connecting-03-02.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    private var connectionSub: AnyCancellable? = nil","    private var rssiSub:       AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore,","         _ known: (device: MetaWear?, metadata: MetaWearMetadata)) {","        self.sync = sync","        (self.metawear, self.metadata) = known","        self.rssi = self.metawear?.rssi ?? -100","        self.connection = self.metawear?.connectionState ?? .disconnected","    }","","    func onAppear {","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceUseCase {","","    func trackConnection() {","        connectionSub = metawear?.connectionStatePublisher","            .receive(on: DispatchQueue.main)","            .sink { [weak self] in self?.connection = $0 }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-02.swift","type":"file","fileType":"swift","highlights":[{"line":18},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33}]},"doc://MetaWear/documentation/MetaWear/MetaWear/rssiPublisher":{"role":"symbol","title":"rssiPublisher","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"rssiPublisher"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Most recent RSSI, as pushed from an active "},{"type":"codeVoice","code":"MetaWearScanner"},{"type":"text","text":" or from "},{"type":"codeVoice","code":"CBPeripheralDelegate"},{"type":"text","text":" about every 5 seconds by automatic calls to "},{"type":"codeVoice","code":"updateRSSI()"},{"type":"text","text":" (only while connected). -100  can indicate disconnection."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/rssiPublisher","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/rssipublisher"},"doc://MetaWear/tutorials/MetaWear/Training-Activity-Classification#Collecting-Training-Data":{"role":"pseudoSymbol","title":"Collecting Training Data","abstract":[{"type":"text","text":"Let’s collect training data for CoreML to compute a model for classifying motion data."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification#Collecting-Training-Data","kind":"section","type":"section","url":"\/tutorials\/metawear\/training-activity-classification#Collecting-Training-Data"},"doc://MetaWear/tutorials/MetaWear/Training-Activity-Classification":{"role":"project","title":"Training an Activity Classifier","estimatedTime":"15min","abstract":[{"type":"text","text":"Let’s collect training data for CoreML to compute a model for classifying motion data."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Training-Activity-Classification","kind":"project","type":"topic","url":"\/tutorials\/metawear\/training-activity-classification"},"02-connecting-03-08.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    ...","","}","","extension KnownDeviceUseCase {","","    func resetDeletingLogs() {","        resetSub = metawear?","            .publishWhenConnected()","            .first()","            .deleteLoggedEntries()","            .command(.resetActivities)","            .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","","        metawear?.connect()","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-08.swift","type":"file","fileType":"swift","highlights":[{"line":20},{"line":21},{"line":22}]},"02-connecting-03-01.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","","    private weak var metawear: MetaWear?","    private var rssiSub:       AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore,","         _ known: (device: MetaWear?, metadata: MetaWearMetadata)) {","        self.sync = sync","        (self.metawear, self.metadata) = known","        self.rssi = self.metawear?.rssi ?? -100","    }","","    func onAppear {","        trackRSSI()","    }","","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-01.swift","type":"file","fileType":"swift","highlights":[{"line":3}]},"https://github.com/mbientlab/mbientSwiftUI/blob/52350efd57865ee4f7ac982293fb3e356b1c48c8/Sources/mbientSwiftUI/Device/MetaWearWithLED.swift":{"title":"mbientSwiftUI","titleInlineContent":[{"type":"text","text":"mbientSwiftUI"}],"type":"link","identifier":"https:\/\/github.com\/mbientlab\/mbientSwiftUI\/blob\/52350efd57865ee4f7ac982293fb3e356b1c48c8\/Sources\/mbientSwiftUI\/Device\/MetaWearWithLED.swift","url":"https:\/\/github.com\/mbientlab\/mbientSwiftUI\/blob\/52350efd57865ee4f7ac982293fb3e356b1c48c8\/Sources\/mbientSwiftUI\/Device\/MetaWearWithLED.swift"},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#List-nearby-devices":{"role":"pseudoSymbol","title":"List nearby devices","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#List-nearby-devices","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#List-nearby-devices"},"02-connecting-02-01.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    private weak var metawear:  MetaWear?","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?)) {","        self.metawear = nearby.metawear","    }","","}","","\/\/ * Called by the factory object creating the use case *","","class MetaWearSyncStore {","","    func getDevice(byLocalCBUUID: CBPeripheralIdentifier)","    -> (device: MetaWear?, metadata: MetaWearMetadata?)","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-01.swift","type":"file","fileType":"swift","highlights":[{"line":5},{"line":15},{"line":16}]},"doc://MetaWear/tutorials/MetaWear/Connecting-to-MetaWears#First-connection":{"role":"pseudoSymbol","title":"First connection","abstract":[{"type":"text","text":"Learn how "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":" finds and manages both nearby and cloud-synced MetaWears."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Connecting-to-MetaWears#First-connection","kind":"section","type":"section","url":"\/tutorials\/metawear\/connecting-to-metawears#First-connection"},"doc://MetaWear/tutorials/MetaWear/Discover-&-Connect":{"role":"article","title":"Discover & Connect","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Discover-&-Connect","kind":"article","type":"topic","url":"\/tutorials\/metawear\/discover-&-connect"},"doc://MetaWear/tutorials/MetaWear":{"role":"overview","title":"From Zero to Machine Learning","abstract":[{"type":"text","text":"Control MetaWear wearable sensors to classify movement. Let’s build "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Streamy"}]},{"type":"text","text":", a barebones app using "},{"type":"codeVoice","code":"Swift"},{"type":"text","text":", "},{"type":"codeVoice","code":"Combine"},{"type":"text","text":", "},{"type":"codeVoice","code":"CoreML"},{"type":"text","text":", and "},{"type":"codeVoice","code":"SwiftUI"},{"type":"text","text":"."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear","kind":"overview","type":"topic","url":"\/tutorials\/metawear"},"02-connecting-03-03.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    private var identitySub:   AnyCancellable? = nil","    private var connectionSub: AnyCancellable? = nil","    private var rssiSub:       AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore,","         _ known: (device: MetaWear?, metadata: MetaWearMetadata)) {","        self.sync = sync","        (self.metawear, self.metadata) = known","        self.rssi = self.metawear?.rssi ?? -100","        self.connection = self.metawear?.connectionState ?? .disconnected","    }","","    func onAppear {","        trackIdentity()","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceUseCase {","","    func trackIdentity() {","        identitySub = sync?.publisher(for: metadata.mac)","            .receive(on: DispatchQueue.main)","            .sink { [weak self] deviceReference, metadata in","                self?.metawear = deviceReference","                self?.metadata = metadata","            }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-03.swift","type":"file","fileType":"swift","highlights":[{"line":10},{"line":23},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38}]},"02-connecting-03-09.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","    @Published var showRenameInvalidPrompt: Bool = false","","    private weak var metawear: MetaWear?","    ...","","}","","extension KnownDeviceUseCase {","","    func rename(_ newName: String) {","        do { try sync?.rename(known: metadata, to: newName) }","        catch { showRenameInvalidPrompt = true }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-09.swift","type":"file","fileType":"swift","highlights":[{"line":8},{"line":17},{"line":18},{"line":19}]},"doc://MetaWear/tutorials/MetaWear/Logging-Sensor-Data":{"role":"project","title":"Logging Sensor Data","estimatedTime":"15min","abstract":[{"type":"text","text":"Configure an arbitrary number of sensors for logging, exporting time-synced data as CSVs in a folder."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Logging-Sensor-Data","kind":"project","type":"topic","url":"\/tutorials\/metawear\/logging-sensor-data"},"02-connecting-02-07.swift":{"syntax":"swift","content":["class UnknownDeviceUseCase: ObservableObject {","","    let name: String","    let isCloudSynced: Bool","    @Published private(set) var rssi: Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear:  MetaWear?","    private weak var sync:      MetaWearSyncStore?","    private weak var tasks:     UnownedCancellableStore?","    private      var rssiSub:   AnyCancellable? = nil","","    init(nearby: (MetaWear, metadata: MetaWearMetadata?),","         sync:   MetaWearSyncStore,","         tasks:  UnownedCancellableStore) {","        self.metawear = nearby.metawear","        self.name = nearby.metadata?.name ?? nearby.metawear.name","        self.isCloudSynced = nearby.metadata?.hasCloudSyncedInfo == true","        self.rssi = nearby.metawear.rssi","        self.connection = nearby.metawear.connectionState","        self.sync = sync","        self.tasks = tasks","    }","","    func onAppear() {","        rssiSub = metawear?.rssiPublisher","            .onMain()","            .sink { [weak self] in self?.rssi = $0 }","    }","","    func remember() {","        guard let id = metawear?.localBluetoothID,","              let sync = sync,","              let tasks = tasks else { return }","        self.connection = .connecting","        sync?.connectAndRemember(unknown: id, didAdd: { (device, metadata) in","            device?.publishIfConnected()","                .command(.ledFlash(.Presets.one.pattern))","                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })","                .store(in: tasks.subs)","        })","    }","}"],"fileName":"UnknownDevice.swift","identifier":"02-connecting-02-07.swift","type":"file","fileType":"swift","highlights":[{"line":10},{"line":15},{"line":22},{"line":40}]},"bird-green-yellow.png":{"alt":"Bird art","type":"image","identifier":"bird-green-yellow.png","variants":[{"url":"\/images\/bird-green-yellow@1x.png","traits":["1x","light"]}]},"streamyIcon.png":{"alt":"Streamy app icon","type":"image","identifier":"streamyIcon.png","variants":[{"url":"\/images\/streamyIcon@2x.png","traits":["2x","light"]}]},"02-connecting-01-05.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-05.swift","type":"file","fileType":"swift","highlights":[{"line":26}]},"doc://MetaWear/documentation/MetaWear/MWCommand/resetFactoryDefaults":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWFactoryReset"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"resetFactoryDefaults","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"resetFactoryDefaults"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"MWFactoryReset","preciseIdentifier":"s:8MetaWear14MWFactoryResetV"}],"abstract":[{"type":"text","text":"Wipes any data and settings from the MetaWear."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/resetFactoryDefaults","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/resetfactorydefaults"},"doc://MetaWear/documentation/MetaWear/MetaWear/connect()":{"role":"symbol","title":"connect()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"connect"},{"kind":"text","text":"()"}],"abstract":[{"type":"text","text":"Connect to this MetaWear and, if needed, initializes the C++ library."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear\/connect()","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/metawear\/connect()"},"02-connecting-03-04.swift":{"syntax":"swift","content":["class KnownDeviceUseCase: ObservableObject {","","    var isCloudSynced: Bool { metawear == nil }","","    @Published private(set) var metadata:   MetaWearMetadata","    @Published private(set) var rssi:       Int","    @Published private(set) var connection: CBPeripheralState","","    private weak var metawear: MetaWear?","    private var identitySub:   AnyCancellable? = nil","    private var connectionSub: AnyCancellable? = nil","    private var rssiSub:       AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore,","         _ known: (device: MetaWear?, metadata: MetaWearMetadata)) {","        self.sync = sync","        (self.metawear, self.metadata) = known","        self.rssi = self.metawear?.rssi ?? -100","        self.connection = self.metawear?.connectionState ?? .disconnected","    }","","    func onAppear {","        trackIdentity()","        trackRSSI()","        trackConnection()","    }","}","","private extension KnownDeviceUseCase {","","    func trackIdentity() {","        identitySub = sync?.publisher(for: metadata.mac)","            .receive(on: DispatchQueue.main)","            .sink { [weak self] deviceReference, metadata in","                let justFoundMetaWear = self?.metawear == nil && deviceReference != nil","                self?.metawear = deviceReference","                self?.metadata = metadata","","                if justFoundMetaWear {","                    self?.trackRSSI()","                    self?.trackConnection()","                }","            }","    }","}"],"fileName":"KnownDevice.swift","identifier":"02-connecting-03-04.swift","type":"file","fileType":"swift","highlights":[{"line":35},{"line":39},{"line":40},{"line":41},{"line":42}]},"doc://MetaWear/documentation/MetaWear/MWCommand/restart":{"conformance":{"constraints":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" is "},{"type":"codeVoice","code":"MWRestart"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"restart","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"restart"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"MWRestart","preciseIdentifier":"s:8MetaWear9MWRestartV"}],"abstract":[{"type":"text","text":"Restarts, preserving macros, loggers, and settings,"},{"type":"text","text":" "},{"type":"text","text":"but any in-memory activities are lost."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MWCommand\/restart","kind":"symbol","type":"topic","url":"\/documentation\/metawear\/mwcommand\/restart"},"doc://MetaWear/tutorials/MetaWear/Adding-MetaWear-to-a-Project":{"role":"project","title":"Adding MetaWear to a Project","estimatedTime":"5min","abstract":[{"type":"text","text":"This tutorial examines the dependencies and permissions needed for the SDK."}],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Adding-MetaWear-to-a-Project","kind":"project","type":"topic","url":"\/tutorials\/metawear\/adding-metawear-to-a-project"},"02-connecting-01-06.swift":{"syntax":"swift","content":["import MetaWear","import MetaWearSync","import Combine","","class DeviceListUseCase: ObservableObject {","","    @Published private(set) var unknownDevices: [CBPeripheralIdentifier] = []","    @Published private(set) var knownDevices:   [MACAddress] = []","","    private weak var scanner: MetaWearScanner?","    private weak var sync:    MetaWearSyncStore?","    private var unknownSub:   AnyCancellable? = nil","","    init(_ sync: MetaWearSyncStore, _ scanner: MetaWearScanner) {","        self.sync = sync","        self.scanner = scanner","    }","}","","extension DeviceListUseCase {","","    func onAppear() {","        scanner?.startScan(higherPerformanceMode: true)","","        unknownSub = sync?.unknownDevices","            .receive(on: DispatchQueue.main)","            .sink { [weak self] ids in self?.unknownDevices = ids.sorted() }","    }","","    func onDisappear() {","        scanner?.stopScan()","    }","}"],"fileName":"DeviceList.swift","identifier":"02-connecting-01-06.swift","type":"file","fileType":"swift","highlights":[{"line":27}]},"doc://MetaWear/documentation/MetaWear/MetaWear":{"role":"symbol","title":"MetaWear","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"MetaWear"}],"abstract":[{"type":"text","text":"Each MetaWear object corresponds a physical MetaWear board. This SDK"},{"type":"text","text":" "},{"type":"text","text":"wraps type-safe Swift methods and Combine publishers around C\/C++ functions"},{"type":"text","text":" "},{"type":"text","text":"and CoreBluetooth APIs so you can get started quickly."}],"identifier":"doc:\/\/MetaWear\/documentation\/MetaWear\/MetaWear","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MetaWear"}],"url":"\/documentation\/metawear\/metawear"},"bird-teal.png":{"alt":"Bird art","type":"image","identifier":"bird-teal.png","variants":[{"url":"\/images\/bird-teal@1x.png","traits":["1x","light"]}]},"doc://MetaWear/tutorials/MetaWear/Log-Sensor-Data":{"role":"article","title":"Log Sensor Data","abstract":[],"identifier":"doc:\/\/MetaWear\/tutorials\/MetaWear\/Log-Sensor-Data","kind":"article","type":"topic","url":"\/tutorials\/metawear\/log-sensor-data"}}}